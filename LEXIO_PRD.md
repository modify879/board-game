# 렉시오(Lexio) 게임 서버 제품 요구사항 정의서 (PRD)

## 1. 프로젝트 개요

* **프로젝트명**: Board Game Server - Lexio Module
* **목표**: 스프링 부트(Kotlin) 기반의 DDD 아키텍처를 사용하여 렉시오(Lexio) 보드게임을 구현하고, WebSocket을 통해 실시간 멀티플레이를 지원한다.
* **기술 스택**: Spring Boot, Kotlin, WebSocket (STOMP), In-memory Cache

## 2. 도메인 용어 정의

| 용어              | 설명                                                  |
|:----------------|:----------------------------------------------------|
| **타일 (Tile)**   | 게임의 기본 단위. **숫자**(1~15)와 **문양**(해, 달, 별, 구름)으로 구성됨. |
| **덱 (Deck)**    | 게임에 사용되는 전체 타일 세트. 인원수에 따라 구성이 달라짐.                 |
| **족보 (Hand)**   | 플레이어가 낼 수 있는 유효한 타일 조합 (싱글, 페어, 트리플, 스트레이트 등).      |
| **라운드 (Round)** | 타일을 나누고 한 명이 타일을 모두 털어낼 때까지의 한 게임 단위.               |
| **턴 (Turn)**    | 플레이어가 타일을 내거나 패스할 수 있는 기회.                          |
| **방 (Room)**    | 하나의 게임이 진행되는 독립적인 공간 (멀티 룸 지원).                     |

## 3. 게임 규칙

### 3.1. 타일 서열 (Ranking)

* **숫자 서열**: **2** (최강) > **1** > **15** > **14** > ... > **4** > **3** (최약).
* **문양 서열**: **해**(Sun, 빨강) > **달**(Moon, 노랑) > **별**(Star, 초록) > **구름**(Cloud, 파랑).
* **비교 원칙**: 숫자가 높을수록 강하며, 숫자가 같으면 문양 서열을 따름.

### 3.2. 게임 준비 (인원별 세팅)

* **3인**: 1~9번 타일 사용 (총 36개), 인당 12개.
* **4인**: 1~13번 타일 사용 (총 52개), 인당 13개.
* **5인**: 1~15번 타일 사용 (총 60개), 인당 12개.
* **초기 점수**: 각 플레이어는 **64점**을 가지고 시작함.
* **선 플레이어**: **구름 3**을 가진 플레이어가 첫 턴을 가짐 (첫 턴에 반드시 구름 3을 낼 필요는 없음).

### 3.3. 유효 족보 (Combinations)

플레이어는 앞 사람이 낸 족보와 **같은 개수**이면서 **더 높은 서열**의 족보만 낼 수 있음.

1. **싱글 (1장)**: 1장 냄. (서열: 숫자 > 문양)
2. **페어 (2장)**: 같은 숫자 2장. (서열: 숫자 > 문양)
3. **트리플 (3장)**: 같은 숫자 3장.
4. **5장 족보 (서열 낮은 순 -> 높은 순)**:
    * **스트레이트 (Straight)**: 연속된 숫자 5개.
        * **서열**: `1-2-3-4-5` (최강) > `12-13-14-15-1` (백 스트레이트) > ... > `3-4-5-6-7` (최약).
        * *주의*: 2를 넘어가는 연결(예: 13-1-2-3-4)은 불가능.
        * 비교: 구성하는 숫자 중 가장 높은 숫자로 비교 (같으면 문양).
    * **플러시 (Flush)**: 같은 문양 5개. (서열: 가장 높은 숫자 > 그 다음 숫자... 순으로 비교)
    * **풀 하우스 (Full House)**: 트리플 + 페어. (서열: 트리플의 숫자로 비교)
    * **포 카드 (Four of a Kind)**: 같은 숫자 4장 + 아무거나 1장. (서열: 포 카드의 숫자로 비교)
    * **스트레이트 플러시 (Straight Flush)**: 같은 문양의 스트레이트. (서열: 가장 높은 숫자로 비교)

### 3.4. 진행 및 승패

1. **선공**: 구름 3 보유자가 선. 자유롭게 족보 제출.
2. **응수**: 다음 사람은 앞 사람보다 높은 족보(개수 동일)를 내야 함.
    * *예외*: 5장 족보끼리는 개수가 같으므로, 더 높은 등급의 족보로 덮을 수 있음 (예: 스트레이트 < 플러시).
3. **패스**: 낼 타일이 없거나 전략적으로 안 낼 경우 패스.
4. **트릭 종료**: 나를 제외한 전원이 패스하면, 마지막에 낸 사람이 새로운 선이 되어 원하는 족보를 냄.
5. **승리**: 한 명이라도 손에 있는 타일을 모두 털어내면 즉시 라운드 종료.

### 3.5. 점수 계산 (Scoring)

* **기본 원칙**: 패자는 (자신의 남은 타일 수) - (승자의 남은 타일 수=0) 만큼 칩을 승자에게 지불.
* **상호 정산**: 2등, 3등, 4등 끼리도 타일 수 차이만큼 주고받음.
* **2 페널티 (The '2' Penalty)**:
    * 게임 종료 시 손에 **숫자 2** 타일을 가지고 있다면 벌칙 적용.
    * 공식: `지불할 점수 = (타일 차이) * 2^(손에 있는 2의 개수)`
    * 예: 2가 1장이면 2배, 2가 2장이면 4배.

## 4. 시스템 요구사항

### 4.1. 아키텍처 (DDD)

* **Domain**: `LexioGame`, `LexioUser`, `Hand`, `LexioTile` 등 핵심 비즈니스 로직 포함. 순수 Kotlin 코드로 작성.
* **애그리거트 루트(Aggregate Root)**: `LexioGame` 등 핵심 엔티티는 `data class`가 아닌 **`class` 파일로 작성**하여 행위와 상태를 캡슐화함.
* **Application**: `PlayTurnUseCase`, `StartGameUseCase` 등 유스케이스 흐름 제어.
* **Infrastructure**: 저장소 구현체 (`ConcurrentHashMap`), 웹소켓 설정 등 기술적 세부 사항.
* **Presentation**: STOMP 컨트롤러, DTO.

### 4.2. 통신 (WebSocket)

* 프로토콜: **STOMP** (Simple Text Oriented Messaging Protocol)
* 엔드포인트: `/ws`
* 구독 경로: `/topic/game/{gameId}` (게임 상태 브로드캐스트)
* 발행 경로: `/app/game/{gameId}/action` (플레이어 액션)

### 4.3. 데이터 저장 (Storage)

* **로컬 캐시**: `ConcurrentHashMap<String, LexioGame>`을 사용하여 게임 상태를 메모리에 저장.
* **멀티 룸**: `gameId`를 키로 하여 여러 게임 인스턴스를 동시에 관리.

## 5. 기능 명세 (Functional Specs)

### 5.1. 방 관리 (Room Management)

* **방 생성**: 호스트가 게임 방을 생성하면 `gameId` 발급.
* **방 참여**: 플레이어는 `gameId`로 입장.

### 5.2. 게임 진행 (Game Flow)

1. **Game Start**: 인원(3~5) 충족 시 시작 -> 덱 셔플 & 분배 -> 초기 점수(64) 세팅 -> 선 플레이어 지정.
2. **Turn Play**: 클라이언트가 낼 타일 목록 전송 -> 서버가 유효성(족보, 서열) 검증 -> 성공 시 상태 업데이트 및 브로드캐스트.
3. **Pass**: 클라이언트가 패스 요청 -> 다음 턴으로 넘김 -> 전원 패스 시 필드 초기화.
4. **Game End**: 손패가 0인 플레이어 발생 시 -> 점수 계산 -> 결과 전송.

## 6. 데이터 구조 예시 (Data Structure)

```kotlin
class LexioGame(
    val gameId: String,
    private val players: MutableList<LexioUser>,
    private var deck: LexioDeck,
    private var status: GameStatus
) {
    var currentTurnPlayerId: String = ""
        private set

    var field: FieldState = FieldState.empty()
        private set

    // 비즈니스 로직 (행위)
    fun start() { ... }
    fun playTurn(player: LexioUser, hand: Hand) { ... }
    fun passTurn(player: LexioUser) { ... }
    private fun calculateScore() { ... }
}
```
